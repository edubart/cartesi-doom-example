/* Generated by Nelua 0.2.0-dev */
/* Compile command: emcc -x c "fbdoom-machine/fbdoom-machine.c" -x none -I "/home/bart/projects/cartesi-doom-example/fbdoom-machine/deps" -fwrapv -fno-strict-aliasing -Oz -DNDEBUG -L/home/bart/projects/cartesi/corp/machine-emulator-sdk/emulator/src -lm -lGL -lcartesi -o "fbdoom-machine/fbdoom-machine" */
/* Compile hash: 2Xr5vP2hEejN1iUeQqLn5T6Ms17x */
/* ------------------------------ DIRECTIVES -------------------------------- */
/* Enable 64 bit offsets for stdio APIs. */
#if !defined(_FILE_OFFSET_BITS) && __SIZEOF_LONG__ >= 8
  #define _FILE_OFFSET_BITS 64
#endif
/* Enable POSIX APIs in included headers. */
#if !defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE) && !defined(_GNU_SOURCE) && !defined(_DEFAULT_SOURCE)
  #if defined(__gnu_linux__)
    #define _GNU_SOURCE
  #else
    #define _XOPEN_SOURCE 600
  #endif
#endif
#include <string.h>
/* Macro used to force inlining a function. */
#ifdef __GNUC__
  #define NELUA_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
  #define NELUA_INLINE __forceinline
#elif __STDC_VERSION__ >= 199901L
  #define NELUA_INLINE inline
#else
  #define NELUA_INLINE
#endif
#include <stdint.h>
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_UNLIKELY(x) __builtin_expect(x, 0)
#else
  #define NELUA_UNLIKELY(x) (x)
#endif
#include <stddef.h>
#include <stdbool.h>
#define NELUA_NIL (nlniltype){}
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_LIKELY(x) __builtin_expect(x, 1)
#else
  #define NELUA_LIKELY(x) (x)
#endif
/* Macro used to force not inlining a function. */
#ifdef __GNUC__
  #define NELUA_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
  #define NELUA_NOINLINE __declspec(noinline)
#else
  #define NELUA_NOINLINE
#endif
#include <stdio.h>
#include <stdlib.h>
/* Macro used to import/export extern C functions. */
#ifdef __cplusplus
  #define NELUA_EXTERN extern "C"
#else
  #define NELUA_EXTERN extern
#endif
/* Macro used to generate traceback on aborts when sanitizing. */
#if defined(__clang__) && defined(__has_feature)
  #if __has_feature(undefined_behavior_sanitizer)
    #define NELUA_UBSAN_UNREACHABLE __builtin_unreachable
  #endif
#elif defined(__gnu_linux__) && defined(__GNUC__) && __GNUC__ >= 5
  NELUA_EXTERN void __ubsan_handle_builtin_unreachable(void*) __attribute__((weak));
  #define NELUA_UBSAN_UNREACHABLE() {if(&__ubsan_handle_builtin_unreachable) __builtin_unreachable();}
#endif
#ifndef NELUA_UBSAN_UNREACHABLE
  #define NELUA_UBSAN_UNREACHABLE()
#endif
/* Macro used to specify a function that never returns. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_NORETURN _Noreturn
#elif defined(__GNUC__)
  #define NELUA_NORETURN __attribute__((noreturn))
#elif defined(_MSC_VER)
  #define NELUA_NORETURN __declspec(noreturn)
#else
  #define NELUA_NORETURN
#endif
/* Macro used sign that a type punning cast may alias (related to strict aliasing). */
#ifdef __GNUC__
  #define NELUA_MAYALIAS __attribute__((may_alias))
#else
  #define NELUA_MAYALIAS
#endif
#include <errno.h>
#include <emscripten.h>
#include <sys/stat.h>
#include <math.h>
#define SOKOL_APP_API_DECL static
#define SOKOL_APP_IMPL
#define SOKOL_NO_ENTRY
#define SOKOL_GLES2
#include <sokol_app.h>
#define SOKOL_GFX_API_DECL static
#define SOKOL_GFX_IMPL
#include <sokol_gfx.h>
#define SOKOL_GP_API_DECL static
#define SOKOL_GP_IMPL
#include <sokol_gp.h>
#define MA_API static
#define MA_NO_PTHREAD_IN_HEADER
#define MINIAUDIO_IMPLEMENTATION
#include <miniaudio.h>
#include <cartesi.h>
/* Macro used to take reference of literals. */
#define NELUA_LITERAL_REF(T, x) (&((struct{T v;}){x}.v))
/* ------------------------------ DECLARATIONS ------------------------------ */
static NELUA_INLINE void nelua_memory_copy(void* dest, void* src, uintptr_t n);
static NELUA_INLINE void nelua_memory_zero(void* dest, uintptr_t n);
static NELUA_INLINE void* nelua_memory_scan(void* src, uint8_t x, uintptr_t n);
typedef struct nelua_span_uint8_ nelua_span_uint8_;
typedef uint8_t* nluint8_arr0_ptr;
struct nelua_span_uint8_ {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
static NELUA_INLINE bool nelua_span_uint8__empty(nelua_span_uint8_ self);
typedef uint8_t* nluint8_ptr;
static NELUA_INLINE nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8_ self, uintptr_t i);
typedef struct nlstring nlstring;
typedef nlstring* nlstring_ptr;
struct nlstring {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
typedef struct nelua_span_string_ nelua_span_string_;
typedef nlstring* nlstring_arr0_ptr;
struct nelua_span_string_ {
  nlstring_arr0_ptr data;
  uintptr_t size;
};
static NELUA_INLINE nlstring_ptr nelua_span_string____atindex(nelua_span_string_ self, uintptr_t i);
typedef struct nlniltype {} nlniltype;
typedef struct nlniltype nltype;
typedef struct nelua_sequence_string__1 nelua_sequence_string__1;
typedef nelua_sequence_string__1* nelua_sequence_string__1_ptr;
typedef struct nelua_sequenceimpl_string__1 nelua_sequenceimpl_string__1;
typedef nelua_sequenceimpl_string__1* nelua_sequenceimpl_string__1_ptr;
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
struct nelua_GeneralAllocator {};
struct nelua_sequence_string__1 {
  nelua_sequenceimpl_string__1_ptr impl;
  nelua_GeneralAllocator allocator;
};
struct nelua_sequenceimpl_string__1 {
  nelua_span_string_ data;
  uintptr_t size;
};
static void nelua_sequence_string__1__init(nelua_sequence_string__1_ptr self);
static void nelua_sequence_string__1_reserve(nelua_sequence_string__1_ptr self, uintptr_t n);
static NELUA_NOINLINE void nelua_sequenceT_grow_1(nelua_sequence_string__1_ptr self);
static NELUA_INLINE nlstring_ptr nelua_sequence_string__1___atindex(nelua_sequence_string__1_ptr self, uintptr_t pos);
static NELUA_INLINE void nelua_write_stderr(const char* msg, uintptr_t len, bool flush);
static NELUA_NORETURN void nelua_abort(void);
static void nelua_assert_msg_nlvoid(bool cond, nlstring msg);
static nelua_GeneralAllocator nelua_general_allocator;
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
static NELUA_INLINE void* nelua_GeneralAllocator_alloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_INLINE void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static NELUA_INLINE void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void* nelua_GeneralAllocator_xalloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_NORETURN void nelua_panic_string(nlstring s);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static nelua_span_string_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_uint8_ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s);
static nelua_span_string_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static nelua_span_string_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static nelua_span_uint8_ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_sequenceimpl_string__1_ptr nelua_GeneralAllocator_new_3(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
typedef ma_sound* ma_sound_ptr;
static ma_sound_ptr nelua_GeneralAllocator_new_4(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
typedef ma_audio_buffer* ma_audio_buffer_ptr;
static ma_audio_buffer_ptr nelua_GeneralAllocator_new_5(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static ma_sound_ptr nelua_new_1(nlniltype what, nlniltype size, nlniltype flags);
static ma_audio_buffer_ptr nelua_new_2(nlniltype what, nlniltype size, nlniltype flags);
static NELUA_INLINE bool nelua_strchar_1_isdigit(uint8_t c);
typedef struct NELUA_MAYALIAS nluint8_arr32 {uint8_t v[32];} nluint8_arr32;
typedef union NELUA_MAYALIAS nluint8_arr32_cast {nluint8_arr32 a; uint8_t p[32];} nluint8_arr32_cast;
typedef nluint8_arr32* nluint8_arr32_ptr;
static uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form);
typedef struct nelua_stringbuilderT nelua_stringbuilderT;
typedef nelua_stringbuilderT* nelua_stringbuilderT_ptr;
struct nelua_stringbuilderT {
  nelua_span_uint8_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
static void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self);
static bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize);
static nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n);
static bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n);
typedef struct nlmulret_nlboolean_nlusize {
  bool r1;
  uintptr_t r2;
} nlmulret_nlboolean_nlusize;
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_2(nelua_stringbuilderT_ptr self, nlstring fmt);
static nlstring nelua_stringbuilderT_view(nelua_stringbuilderT_ptr self);
typedef FILE* FILE_ptr;
typedef struct nelua_filestream nelua_filestream;
typedef nelua_filestream* nelua_filestream_ptr;
typedef struct nelua_FStream nelua_FStream;
typedef nelua_FStream* nelua_FStream_ptr;
struct nelua_filestream {
  nelua_FStream_ptr fs;
};
typedef int (*function_4shZxa6X2RDeLYUsL)(FILE_ptr);
struct nelua_FStream {
  FILE_ptr fp;
  function_4shZxa6X2RDeLYUsL closef;
};
static NELUA_INLINE FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self);
typedef struct nlmulret_nlstring_nlint64 {
  nlstring r1;
  int64_t r2;
} nlmulret_nlstring_nlint64;
static nlmulret_nlstring_nlint64 nelua_geterrno(void);
static NELUA_INLINE nlstring nelua_cstring2string(const char* s);
typedef struct nlmulret_nlboolean_nlstring_nlint64 {
  bool r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlboolean_nlstring_nlint64;
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_flush(nelua_filestream_ptr self);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_1(nelua_filestream_ptr self, nlstring fmt);
static void nelua_filestream_printf_1(nelua_filestream_ptr self, nlstring __arg1);
static nelua_FStream nelua_stdoutfs;
static nelua_filestream nelua_io_stdout;
static void nelua_io_printf_1(nlstring __arg1);
static nltype nelua_require_io(nlniltype modname);
static double nelua_os_now(void);
static bool nelua_os_sleep(double secs);
typedef uint32_t fs_fs_StatKind;
static fs_fs_StatKind fs_kind_from_mode(unsigned int mode);
typedef struct fs_fs_StatInfo fs_fs_StatInfo;
struct fs_fs_StatInfo {
  fs_fs_StatKind kind;
  uint64_t dev;
  uint64_t ino;
  uint64_t nlink;
  uint32_t mode;
  uint32_t uid;
  uint32_t gid;
  uint64_t rdev;
  int64_t size;
  int64_t atime;
  int64_t mtime;
  int64_t ctime;
  int64_t blksize;
  int64_t blocks;
};
typedef struct nlmulret_fs_fs_StatInfo_nlstring_nlint64 {
  fs_fs_StatInfo r1;
  nlstring r2;
  int64_t r3;
} nlmulret_fs_fs_StatInfo_nlstring_nlint64;
static nlmulret_fs_fs_StatInfo_nlstring_nlint64 fs_fs_stat_1(nlstring path, nlniltype linkstat);
typedef struct stat stat_t;
static NELUA_INLINE char* nelua_string2cstring(nlstring s);
static NELUA_INLINE double nelua_math_floor_1(double x);
static NELUA_INLINE int64_t nelua_math_ifloor_1(double x);
static nelua_sequence_string__1 nelua_arg;
static int nelua_argc;
typedef char** nlcstring_arr0_ptr;
static nlcstring_arr0_ptr nelua_argv;
static nelua_sequence_string__1 nelua_require_arg(nlniltype modname);
static sg_context_desc deps_sokol_glue_sapp_sgcontext(void);
typedef struct cartesi_utils_CartesiMachine cartesi_utils_CartesiMachine;
typedef cm_machine* cm_machine_ptr;
struct cartesi_utils_CartesiMachine {
  cm_machine_ptr machine;
};
static cartesi_utils_CartesiMachine cartesi_utils_CartesiMachine_create(cm_machine_config config);
typedef cm_machine_config* cm_machine_config_ptr;
static NELUA_INLINE bool nelua_eq_cm_ram_config(cm_ram_config a, cm_ram_config b);
static NELUA_INLINE bool nelua_eq_cm_htif_config(cm_htif_config a, cm_htif_config b);
static NELUA_INLINE bool nelua_eq_cm_memory_range_config_array(cm_memory_range_config_array a, cm_memory_range_config_array b);
typedef cartesi_utils_CartesiMachine* cartesi_utils_CartesiMachine_ptr;
static CM_BREAK_REASON cartesi_utils_CartesiMachine_run_1(cartesi_utils_CartesiMachine_ptr self, nlniltype mcycle_end);
static uint32_t cartesi_utils_CartesiMachine_read_yield_reason(cartesi_utils_CartesiMachine_ptr self);
static void cartesi_utils_CartesiMachine_read_memory(cartesi_utils_CartesiMachine_ptr self, uint64_t paddr, nelua_span_uint8_ dest);
typedef unsigned char* nlcuchar_ptr;
static void cartesi_utils_CartesiMachine_write_memory(cartesi_utils_CartesiMachine_ptr self, uint64_t paddr, nelua_span_uint8_ dest);
static uint64_t cartesi_utils_CartesiMachine_read_mcycle(cartesi_utils_CartesiMachine_ptr self);
static cartesi_utils_CartesiMachine fbdoom_machine_fbdoom_machine_machine;
static char nelua_strlit_1[163] = "console=hvc0 rootfstype=ext2 root=/dev/mtdblock0 rw quiet swiotlb=noforce mtdparts=flash.0:-(root) hugepagesz=2M hugepages=1 -- /root/fbdoom -iwad /root/doom1.wad";
typedef struct NELUA_MAYALIAS cm_memory_range_config_arr8 {cm_memory_range_config v[8];} cm_memory_range_config_arr8;
typedef union NELUA_MAYALIAS cm_memory_range_config_arr8_cast {cm_memory_range_config_arr8 a; cm_memory_range_config p[8];} cm_memory_range_config_arr8_cast;
static ma_engine fbdoom_machine_fbdoom_machine_audio_engine;
typedef struct NELUA_MAYALIAS nluint8_arr1048576 {uint8_t v[1048576];} nluint8_arr1048576;
typedef union NELUA_MAYALIAS nluint8_arr1048576_cast {nluint8_arr1048576 a; uint8_t p[1048576];} nluint8_arr1048576_cast;
static nluint8_arr1048576 fbdoom_machine_fbdoom_machine_framebuffer;
typedef struct NELUA_MAYALIAS nluint8_arr524288 {uint8_t v[524288];} nluint8_arr524288;
typedef union NELUA_MAYALIAS nluint8_arr524288_cast {nluint8_arr524288 a; uint8_t p[524288];} nluint8_arr524288_cast;
static nluint8_arr524288 fbdoom_machine_fbdoom_machine_audiobuffer;
typedef struct NELUA_MAYALIAS nluint32_arr1048576 {uint32_t v[1048576];} nluint32_arr1048576;
typedef union NELUA_MAYALIAS nluint32_arr1048576_cast {nluint32_arr1048576 a; uint32_t p[1048576];} nluint32_arr1048576_cast;
static nluint32_arr1048576 fbdoom_machine_fbdoom_machine_framebuffer_rgba;
typedef struct riv_framebuffer_desc riv_framebuffer_desc;
struct riv_framebuffer_desc {
  uint32_t height;
  uint32_t width;
  uint32_t fps;
  uint32_t pixel_format;
};
static riv_framebuffer_desc fbdoom_machine_fbdoom_machine_lastfb_desc;
static sg_image fbdoom_machine_fbdoom_machine_fb_image;
typedef struct riv_desc riv_desc;
typedef struct riv_audio_ctl_desc riv_audio_ctl_desc;
typedef uint32_t riv_audio_command;
struct riv_audio_ctl_desc {
  riv_audio_command command;
  uint32_t handle_id;
  uint32_t data_size;
  uint32_t volume;
};
typedef struct riv_keystate riv_keystate;
struct riv_keystate {
  uint64_t down_frame;
  uint64_t up_frame;
};
struct riv_desc {
  uint8_t magic[32];
  uint32_t version;
  uint64_t frame;
  riv_audio_ctl_desc audio_ctl;
  riv_framebuffer_desc framebuffer;
  riv_keystate keys[512];
  uint32_t palette[256];
};
static riv_desc fbdoom_machine_fbdoom_machine_desc;
static uint64_t fbdoom_machine_fbdoom_machine_frame_count = 0U;
static double fbdoom_machine_fbdoom_machine_next_frame_time = 0.0;
static double fbdoom_machine_fbdoom_machine_last_frame_time = 0.0;
static void fbdoom_machine_fbdoom_machine_refresh_riv_desc(void);
static void fbdoom_machine_fbdoom_machine_present(void);
static void fbdoom_machine_fbdoom_machine_audio_ctl(void);
typedef ma_allocation_callbacks* ma_allocation_callbacks_ptr;
static void fbdoom_machine_fbdoom_machine_limit_fps(void);
static void fbdoom_machine_fbdoom_machine_machine_poll(void);
static void nelua_print_1(nlstring a1);
static void fbdoom_machine_fbdoom_machine_machine_frame_poll(void);
typedef sapp_event* sapp_event_ptr;
static void fbdoom_machine_fbdoom_machine_event(sapp_event_ptr event_1);
static void fbdoom_machine_fbdoom_machine_frame(void);
typedef struct NELUA_MAYALIAS sg_range_arr16_arr6 {sg_range v[6][16];} sg_range_arr16_arr6;
typedef union NELUA_MAYALIAS sg_range_arr16_arr6_cast {sg_range_arr16_arr6 a; sg_range p[6][16];} sg_range_arr16_arr6_cast;
typedef struct NELUA_MAYALIAS sg_range_arr16 {sg_range v[16];} sg_range_arr16;
typedef union NELUA_MAYALIAS sg_range_arr16_cast {sg_range_arr16 a; sg_range p[16];} sg_range_arr16_cast;
static NELUA_NORETURN void nelua_panic_cstring(const char* s);
static NELUA_INLINE int64_t nelua_idiv_nlint64(int64_t a, int64_t b);
static void fbdoom_machine_fbdoom_machine_init(void);
typedef ma_engine_config* ma_engine_config_ptr;
static void fbdoom_machine_fbdoom_machine_cleanup(void);
static sapp_desc fbdoom_machine_fbdoom_machine_app_desc = {.init_cb = fbdoom_machine_fbdoom_machine_init, .frame_cb = fbdoom_machine_fbdoom_machine_frame, .cleanup_cb = fbdoom_machine_fbdoom_machine_cleanup, .event_cb = fbdoom_machine_fbdoom_machine_event, .width = 320, .height = 240, .window_title = (char*)"Cartesi FBDoom"};
static int nelua_main(int argc, char** argv);
/* ------------------------------ DEFINITIONS ------------------------------- */
void nelua_memory_copy(void* dest, void* src, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  memcpy(dest, src, (size_t)n);
}
void nelua_memory_zero(void* dest, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  memset(dest, 0, (size_t)n);
}
void* nelua_memory_scan(void* src, uint8_t x, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return (void*)NULL;
  }
  return memchr(src, (int)x, (size_t)n);
}
bool nelua_span_uint8__empty(nelua_span_uint8_ self) {
  return (self.size == 0);
}
nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8_ self, uintptr_t i) {
  return (&self.data[i]);
}
nlstring_ptr nelua_span_string____atindex(nelua_span_string_ self, uintptr_t i) {
  return (&self.data[i]);
}
void nelua_sequence_string__1__init(nelua_sequence_string__1_ptr self) {
  if(NELUA_LIKELY((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GeneralAllocator_new_3((&self->allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void nelua_sequence_string__1_reserve(nelua_sequence_string__1_ptr self, uintptr_t n) {
  nelua_sequence_string__1__init(self);
  uintptr_t cap = (n + 1);
  uintptr_t curcap = self->impl->data.size;
  if((curcap >= cap)) {
    return;
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_2((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*nelua_span_string____atindex(self->impl->data, 0U)) = (nlstring){0};
  }
}
void nelua_sequenceT_grow_1(nelua_sequence_string__1_ptr self) {
  uintptr_t cap = 2U;
  uintptr_t curcap = self->impl->data.size;
  if(NELUA_LIKELY((curcap != 0))) {
    cap = (curcap * 2);
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_2((&self->allocator), self->impl->data, cap);
  if(NELUA_UNLIKELY((curcap == 0))) {
    (*nelua_span_string____atindex(self->impl->data, 0U)) = (nlstring){0};
  }
}
void nelua_write_stderr(const char* msg, uintptr_t len, bool flush) {
  if(len > 0 && msg) {
    fwrite(msg, 1, len, stderr);
  }
  if(flush) {
    fwrite("\n", 1, 1, stderr);
    fflush(stderr);
  }
}
void nelua_abort(void) {
  NELUA_UBSAN_UNREACHABLE();
  abort();
}
void nelua_assert_msg_nlvoid(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr((const char*)msg.data, msg.size, true);
    nelua_abort();
  }
}
nlstring_ptr nelua_sequence_string__1___atindex(nelua_sequence_string__1_ptr self, uintptr_t pos) {
  nelua_sequence_string__1__init(self);
  if(NELUA_UNLIKELY((pos > self->impl->size))) {
    nelua_assert_msg_nlvoid((pos == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(NELUA_UNLIKELY(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow_1(self);
    }
    (*nelua_span_string____atindex(self->impl->data, pos)) = (nlstring){0};
  } else if(NELUA_UNLIKELY(((self->impl->data.size == 0) && (pos == 0)))) {
    nelua_sequenceT_grow_1(self);
  }
  return (&(*nelua_span_string____atindex(self->impl->data, pos)));
}
void* nelua_GeneralAllocator_alloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, 1U);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(NELUA_UNLIKELY((p == (void*)NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(NELUA_UNLIKELY((newsize == 0))) {
    if(NELUA_LIKELY((p != (void*)NULL))) {
      free(p);
    }
    return (void*)NULL;
  } else if(NELUA_UNLIKELY((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void nelua_panic_string(nlstring s) {
  if(s.size > 0) {
    nelua_write_stderr((const char*)s.data, s.size, true);
  }
  nelua_abort();
}
void* nelua_GeneralAllocator_xalloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  void* p = nelua_GeneralAllocator_alloc0_1(self, size, NELUA_NIL);
  if(NELUA_UNLIKELY(((p == (void*)NULL) && (size > 0)))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return p;
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(NELUA_LIKELY(((newsize > oldsize) && (p != (void*)NULL)))) {
    nelua_memory_zero((void*)(&((nluint8_arr0_ptr)p)[oldsize]), (newsize - oldsize));
  }
  return p;
}
nelua_span_string_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nlstring_arr0_ptr data = ((nlstring_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 8), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nlstring_arr0_ptr)NULL)))) {
      return (nelua_span_string_){.data = data, .size = size};
    }
  }
  return (nelua_span_string_){0};
}
nelua_span_uint8_ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GeneralAllocator_alloc0_1(self, (size * 1), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){.data = data, .size = size};
    }
  }
  return (nelua_span_uint8_){0};
}
void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
nelua_span_string_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_1(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlstring_arr0_ptr p = ((nlstring_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlstring_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_string_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_uint8_ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_1(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_sequenceimpl_string__1_ptr nelua_GeneralAllocator_new_3(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_sequenceimpl_string__1_ptr ptr = ((nelua_sequenceimpl_string__1_ptr)nelua_GeneralAllocator_xalloc0_1(self, 12U, NELUA_NIL));
  return ptr;
}
ma_sound_ptr nelua_GeneralAllocator_new_4(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  ma_sound_ptr ptr = ((ma_sound_ptr)nelua_GeneralAllocator_xalloc0_1(self, 672U, NELUA_NIL));
  return ptr;
}
ma_audio_buffer_ptr nelua_GeneralAllocator_new_5(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  ma_audio_buffer_ptr ptr = ((ma_audio_buffer_ptr)nelua_GeneralAllocator_xalloc0_1(self, 120U, NELUA_NIL));
  return ptr;
}
ma_sound_ptr nelua_new_1(nlniltype what, nlniltype size, nlniltype flags) {
  return nelua_GeneralAllocator_new_4((&nelua_general_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
ma_audio_buffer_ptr nelua_new_2(nlniltype what, nlniltype size, nlniltype flags) {
  return nelua_GeneralAllocator_new_5((&nelua_general_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
bool nelua_strchar_1_isdigit(uint8_t c) {
  return (((uint32_t)c - 48U) < 10);
}
uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form) {
  uintptr_t p = 0U;
  while(((strfmt[p] != 0) && (nelua_memory_scan((void*)((nlstring){(uint8_t*)"-+ #0", 5}).data, strfmt[p], 5U) != (void*)NULL))) {
    p = (p + 1);
  }
  nelua_assert_msg_nlvoid((p < (((nlstring){(uint8_t*)"-+ #0", 5}).size + 1)), ((nlstring){(uint8_t*)"invalid format (repeated flags)", 31}));
  if(nelua_strchar_1_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if(nelua_strchar_1_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if((strfmt[p] == 46U)) {
    p = (p + 1);
    if(nelua_strchar_1_isdigit(strfmt[p])) {
      p = (p + 1);
    }
    if(nelua_strchar_1_isdigit(strfmt[p])) {
      p = (p + 1);
    }
  }
  nelua_assert_msg_nlvoid((!nelua_strchar_1_isdigit(strfmt[p])), ((nlstring){(uint8_t*)"invalid format (width or precision too long)", 44}));
  form->v[0] = 37U;
  nelua_memory_copy((void*)(&form->v[1]), (void*)(&strfmt[0]), (p + 1));
  form->v[(p + 2)] = 0U;
  return p;
}
void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self) {
  nelua_GeneralAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_uint8_){0};
  self->size = 0U;
}
bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize) {
  uintptr_t needed = (newsize + 1);
  uintptr_t cap = self->data.size;
  if((needed <= cap)) {
    return true;
  }
  if((cap == 0)) {
    cap = 16U;
  }
  while((cap < needed)) {
    cap = (cap * 2);
    if((cap <= 16U)) {
      return false;
    }
  }
  self->data = nelua_GeneralAllocator_spanrealloc0_1((&self->allocator), self->data, cap);
  if((self->data.size != cap)) {
    self->data = nelua_GeneralAllocator_spanrealloc0_1((&self->allocator), self->data, needed);
  }
  return (needed <= self->data.size);
}
nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n) {
  if((!nelua_stringbuilderT_grow(self, (self->size + n)))) {
    return (nelua_span_uint8_){0};
  }
  return (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(&(*nelua_span_uint8____atindex(self->data, self->size)))), .size = ((self->data.size - self->size) - 1)};
}
void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n) {
  uintptr_t newsize = (self->size + n);
  self->size = newsize;
}
bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n) {
  nelua_span_uint8_ p = nelua_stringbuilderT_prepare(self, 1U);
  if(NELUA_UNLIKELY(nelua_span_uint8__empty(p))) {
    return false;
  }
  p.data[0] = c;
  self->size = (self->size + 1);
  return true;
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_2(nelua_stringbuilderT_ptr self, nlstring fmt) {
  uintptr_t pos = 0U;
  uintptr_t written = 0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NELUA_NIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NELUA_NIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = (nluint8_arr32){0};
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        intptr_t nb = -1;
        nelua_assert_msg_nlvoid(false, ((nlstring){(uint8_t*)"bad format argument (no value)", 30}));
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlstring nelua_stringbuilderT_view(nelua_stringbuilderT_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    return (nlstring){0};
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&(*nelua_span_uint8____atindex(self->data, 0U)))), .size = self->size};
}
FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self) {
  if((!(self->fs != NULL))) {
    return ((FILE_ptr)NULL);
  }
  return self->fs->fp;
}
nlstring nelua_cstring2string(const char* s) {
  if(s == NULL) {
    return (nlstring){0};
  }
  uintptr_t size = strlen(s);
  if(size == 0) {
    return (nlstring){0};
  }
  return (nlstring){(uint8_t*)s, size};
}
nlmulret_nlstring_nlint64 nelua_geterrno(void) {
  return (nlmulret_nlstring_nlint64){nelua_cstring2string(strerror(errno)), (int64_t)errno};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_flush(nelua_filestream_ptr self) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  if((fflush(fp) != 0)) {
    nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
    return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, (nlstring){0}, 0};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_writef_1(nelua_filestream_ptr self, nlstring fmt) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  if((!nelua_stringbuilderT_writef_2((&sb), fmt).r1)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = ((nlstring){(uint8_t*)"not enough memory", 17});
    _mulret_1.r3 = 0;
    { /* defer */
      nelua_stringbuilderT_destroy((&sb));
    }
    return _mulret_1;
  }
  nlstring s = nelua_stringbuilderT_view((&sb));
  if((s.size > 0)) {
    size_t res = fwrite((void*)s.data, 1U, (size_t)s.size, fp);
    if((res != s.size)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      _mulret_2.r1 = false;
      nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
      _mulret_2.r2 = _ret_1.r1;
      _mulret_2.r3 = _ret_1.r2;
      { /* defer */
        nelua_stringbuilderT_destroy((&sb));
      }
      return _mulret_2;
    }
  }
  nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
  _mulret_3.r1 = true;
  _mulret_3.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_3.r3 = 0;
  { /* defer */
    nelua_stringbuilderT_destroy((&sb));
  }
  return _mulret_3;
}
void nelua_filestream_printf_1(nelua_filestream_ptr self, nlstring __arg1) {
  nelua_filestream_writef_1(self, __arg1);
  nelua_filestream_flush(self);
}
void nelua_io_printf_1(nlstring __arg1) {
  nelua_filestream_printf_1((&nelua_io_stdout), __arg1);
}
nltype nelua_require_io(nlniltype modname) {
  nelua_stdoutfs = (nelua_FStream){.fp = stdout};
  nelua_io_stdout = (nelua_filestream){.fs = (&nelua_stdoutfs)};
  return NELUA_NIL;
}
double nelua_os_now(void) {
  double now = emscripten_get_now();
  static bool initialized = false;
  static double first_now = 0.0;
  if((!initialized)) {
    first_now = now;
    initialized = true;
  }
  return ((now - first_now) / 1000.0);
}
bool nelua_os_sleep(double secs) {
  if((secs < 0)) {
    return false;
  }
  return false;
}
fs_fs_StatKind fs_kind_from_mode(unsigned int mode) {
  if(S_ISREG(mode)) {
    return 1U;
  } else if(S_ISDIR(mode)) {
    return 2U;
  } else if(S_ISLNK(mode)) {
    return 3U;
  } else if(S_ISSOCK(mode)) {
    return 4U;
  } else if(S_ISFIFO(mode)) {
    return 5U;
  } else if(S_ISCHR(mode)) {
    return 6U;
  } else if(S_ISBLK(mode)) {
    return 7U;
  }
  return 8U;
}
char* nelua_string2cstring(nlstring s) {
  return (s.size == 0) ? (char*)"" : (char*)s.data;
}
nlmulret_fs_fs_StatInfo_nlstring_nlint64 fs_fs_stat_1(nlstring path, nlniltype linkstat) {
  bool linkstat_1 = false;
  stat_t st = (stat_t){0};
  int res = 0;
  if(linkstat_1) {
    res = lstat(nelua_string2cstring(path), (&st));
  } else {
    res = stat(nelua_string2cstring(path), (&st));
  }
  if((res != 0)) {
    return (nlmulret_fs_fs_StatInfo_nlstring_nlint64){(fs_fs_StatInfo){0}, nelua_cstring2string(strerror(errno)), (int64_t)errno};
  }
  fs_fs_StatInfo si = (fs_fs_StatInfo){.kind = fs_kind_from_mode(st.st_mode), .dev = (uint64_t)st.st_dev, .ino = (uint64_t)st.st_ino, .nlink = (uint64_t)st.st_nlink, .mode = (uint32_t)st.st_mode, .uid = (uint32_t)st.st_uid, .gid = (uint32_t)st.st_gid, .rdev = (uint64_t)st.st_rdev, .size = (int64_t)st.st_size, .atime = st.st_atime, .mtime = st.st_mtime, .ctime = st.st_ctime};
  si.blksize = (int64_t)st.st_blksize;
  si.blocks = (int64_t)st.st_blocks;
  return (nlmulret_fs_fs_StatInfo_nlstring_nlint64){si, (nlstring){0}, 0};
}
double nelua_math_floor_1(double x) {
  return floor(x);
}
int64_t nelua_math_ifloor_1(double x) {
  return (int64_t)nelua_math_floor_1(x);
}
nelua_sequence_string__1 nelua_require_arg(nlniltype modname) {
  if((nelua_argc > 0)) {
    uintptr_t narg = (uintptr_t)(nelua_argc - 1);
    nelua_sequence_string__1_reserve((&nelua_arg), narg);
    for(uintptr_t i = 0U, _end = narg; i <= _end; i += 1) {
      (*nelua_sequence_string__1___atindex((&nelua_arg), i)) = nelua_cstring2string(nelua_argv[i]);
    }
  }
  return nelua_arg;
}
sg_context_desc deps_sokol_glue_sapp_sgcontext(void) {
  sg_context_desc desc = (sg_context_desc){0};
  desc.color_format = (sg_pixel_format)sapp_color_format();
  desc.depth_format = (sg_pixel_format)sapp_depth_format();
  desc.sample_count = sapp_sample_count();
  desc.gl.force_gles2 = sapp_gles2();
  desc.metal.device = sapp_metal_get_device();
  desc.metal.renderpass_descriptor_cb = sapp_metal_get_renderpass_descriptor;
  desc.metal.drawable_cb = sapp_metal_get_drawable;
  desc.d3d11.device = sapp_d3d11_get_device();
  desc.d3d11.device_context = sapp_d3d11_get_device_context();
  desc.d3d11.render_target_view_cb = sapp_d3d11_get_render_target_view;
  desc.d3d11.depth_stencil_view_cb = sapp_d3d11_get_depth_stencil_view;
  desc.wgpu.device = sapp_wgpu_get_device();
  desc.wgpu.render_view_cb = sapp_wgpu_get_render_view;
  desc.wgpu.resolve_view_cb = sapp_wgpu_get_resolve_view;
  desc.wgpu.depth_stencil_view_cb = sapp_wgpu_get_depth_stencil_view;
  return desc;
}
bool nelua_eq_cm_ram_config(cm_ram_config a, cm_ram_config b) {
  return a.length == b.length && a.image_filename == b.image_filename;
}

bool nelua_eq_cm_htif_config(cm_htif_config a, cm_htif_config b) {
  return a.fromhost == b.fromhost && a.tohost == b.tohost && a.console_getchar == b.console_getchar && a.yield_manual == b.yield_manual && a.yield_automatic == b.yield_automatic;
}

bool nelua_eq_cm_memory_range_config_array(cm_memory_range_config_array a, cm_memory_range_config_array b) {
  return a.entry == b.entry && a.count == b.count;
}

cartesi_utils_CartesiMachine cartesi_utils_CartesiMachine_create(cm_machine_config config) {
  cm_machine_config_ptr defconfig = NULL;
  {
      {
        char* errmsg = NULL;
        int result = cm_get_default_config((&defconfig), (&errmsg));
        if((errmsg != NULL)) {
          nelua_panic_string(nelua_cstring2string(errmsg));
        }
        nelua_assert_msg_nlvoid((result == 0), ((nlstring){(uint8_t*)"cartesi machine API error", 25}));
      }
  };
  cm_machine_config mergedconfig = (*defconfig);
  cm_machine_runtime_config runconfig = (cm_machine_runtime_config){0};
  if((!nelua_eq_cm_ram_config(config.ram, (cm_ram_config){0}))) {
    mergedconfig.ram = config.ram;
  }
  if((config.rom, (cm_ram_config){0}, true)) {
    mergedconfig.rom = config.rom;
  }
  if((!nelua_eq_cm_htif_config(config.htif, (cm_htif_config){0}))) {
    mergedconfig.htif = config.htif;
  }
  if((!nelua_eq_cm_memory_range_config_array(config.flash_drive, (cm_memory_range_config_array){0}))) {
    mergedconfig.flash_drive = config.flash_drive;
  }
  cartesi_utils_CartesiMachine self = (cartesi_utils_CartesiMachine){0};
  {
      {
        char* errmsg = NULL;
        int result = cm_create_machine((&mergedconfig), (&runconfig), (&self.machine), (&errmsg));
        if((errmsg != NULL)) {
          nelua_panic_string(nelua_cstring2string(errmsg));
        }
        nelua_assert_msg_nlvoid((result == 0), ((nlstring){(uint8_t*)"cartesi machine API error", 25}));
      }
  };
  { /* defer */
    cm_delete_machine_config(defconfig);
  }
  return self;
}
CM_BREAK_REASON cartesi_utils_CartesiMachine_run_1(cartesi_utils_CartesiMachine_ptr self, nlniltype mcycle_end) {
  uint64_t mcycle_end_1 = 0xffffffffffffffffULL;
  CM_BREAK_REASON break_reason = 0;
  {
      {
        char* errmsg = NULL;
        int result = cm_machine_run(self->machine, mcycle_end_1, (&break_reason), (&errmsg));
        if((errmsg != NULL)) {
          nelua_panic_string(nelua_cstring2string(errmsg));
        }
        nelua_assert_msg_nlvoid((result == 0), ((nlstring){(uint8_t*)"cartesi machine API error", 25}));
      }
  };
  return break_reason;
}
uint32_t cartesi_utils_CartesiMachine_read_yield_reason(cartesi_utils_CartesiMachine_ptr self) {
  uint64_t data = 0U;
  {
      {
        char* errmsg = NULL;
        int result = cm_read_htif_tohost_data(self->machine, (&data), (&errmsg));
        if((errmsg != NULL)) {
          nelua_panic_string(nelua_cstring2string(errmsg));
        }
        nelua_assert_msg_nlvoid((result == 0), ((nlstring){(uint8_t*)"cartesi machine API error", 25}));
      }
  };
  return (uint32_t)(data >> 32);
}
void cartesi_utils_CartesiMachine_read_memory(cartesi_utils_CartesiMachine_ptr self, uint64_t paddr, nelua_span_uint8_ dest) {
  {
      {
        char* errmsg = NULL;
        int result = cm_read_memory(self->machine, paddr, (nlcuchar_ptr)dest.data, (uint64_t)dest.size, (&errmsg));
        if((errmsg != NULL)) {
          nelua_panic_string(nelua_cstring2string(errmsg));
        }
        nelua_assert_msg_nlvoid((result == 0), ((nlstring){(uint8_t*)"cartesi machine API error", 25}));
      }
  };
}
void cartesi_utils_CartesiMachine_write_memory(cartesi_utils_CartesiMachine_ptr self, uint64_t paddr, nelua_span_uint8_ dest) {
  {
      {
        char* errmsg = NULL;
        int result = cm_write_memory(self->machine, paddr, (nlcuchar_ptr)dest.data, (size_t)dest.size, (&errmsg));
        if((errmsg != NULL)) {
          nelua_panic_string(nelua_cstring2string(errmsg));
        }
        nelua_assert_msg_nlvoid((result == 0), ((nlstring){(uint8_t*)"cartesi machine API error", 25}));
      }
  };
}
uint64_t cartesi_utils_CartesiMachine_read_mcycle(cartesi_utils_CartesiMachine_ptr self) {
  uint64_t mcycle = 0U;
  {
      {
        char* errmsg = NULL;
        int result = cm_read_mcycle(self->machine, (&mcycle), (&errmsg));
        if((errmsg != NULL)) {
          nelua_panic_string(nelua_cstring2string(errmsg));
        }
        nelua_assert_msg_nlvoid((result == 0), ((nlstring){(uint8_t*)"cartesi machine API error", 25}));
      }
  };
  return mcycle;
}
void fbdoom_machine_fbdoom_machine_refresh_riv_desc(void) {
  cartesi_utils_CartesiMachine_read_memory((&fbdoom_machine_fbdoom_machine_machine), 2170552320ULL, (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(&fbdoom_machine_fbdoom_machine_desc)), .size = 9296U});
}
void fbdoom_machine_fbdoom_machine_present(void) {
  uint32_t fb_pixel_count = (fbdoom_machine_fbdoom_machine_desc.framebuffer.width * fbdoom_machine_fbdoom_machine_desc.framebuffer.height);
  cartesi_utils_CartesiMachine_read_memory((&fbdoom_machine_fbdoom_machine_machine), 2171600896ULL, (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(&fbdoom_machine_fbdoom_machine_framebuffer)), .size = (uintptr_t)fb_pixel_count});
  if(((fbdoom_machine_fbdoom_machine_lastfb_desc.width != fbdoom_machine_fbdoom_machine_desc.framebuffer.width) || (fbdoom_machine_fbdoom_machine_lastfb_desc.height != fbdoom_machine_fbdoom_machine_desc.framebuffer.height))) {
    if((sg_query_image_state(fbdoom_machine_fbdoom_machine_fb_image) == 2)) {
      sg_destroy_image(fbdoom_machine_fbdoom_machine_fb_image);
    }
    if((fb_pixel_count > 0)) {
      fbdoom_machine_fbdoom_machine_fb_image = sg_make_image(NELUA_LITERAL_REF(sg_image_desc, ((sg_image_desc){.usage = 3, .width = (int)fbdoom_machine_fbdoom_machine_desc.framebuffer.width, .height = (int)fbdoom_machine_fbdoom_machine_desc.framebuffer.height, .min_filter = 1, .mag_filter = 1, .wrap_u = 2, .wrap_v = 2})));
      nelua_assert_msg_nlvoid((sg_query_image_state(fbdoom_machine_fbdoom_machine_fb_image) == 2), ((nlstring){(uint8_t*)"failed to create frame buffer image", 35}));
    }
  }
  fbdoom_machine_fbdoom_machine_lastfb_desc = fbdoom_machine_fbdoom_machine_desc.framebuffer;
}
void fbdoom_machine_fbdoom_machine_audio_ctl(void) {
  nelua_span_uint8_ data = (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(&fbdoom_machine_fbdoom_machine_audiobuffer.v[0])), .size = (uintptr_t)fbdoom_machine_fbdoom_machine_desc.audio_ctl.data_size};
  cartesi_utils_CartesiMachine_read_memory((&fbdoom_machine_fbdoom_machine_machine), 2171076608ULL, data);
  switch(fbdoom_machine_fbdoom_machine_desc.audio_ctl.command) {
    case 1U: {
      ma_sound_ptr sound = nelua_new_1(NELUA_NIL, NELUA_NIL, NELUA_NIL);
      ma_audio_buffer_ptr audio_buffer = nelua_new_2(NELUA_NIL, NELUA_NIL, NELUA_NIL);
      ma_audio_buffer_config config = ma_audio_buffer_config_init(1, 1U, (uint64_t)data.size, (void*)data.data, ((ma_allocation_callbacks_ptr)NULL));
      config.sampleRate = 11025U;
      {
          ma_result result = ma_audio_buffer_init_copy((&config), audio_buffer);
          if((result != 0)) {
            nelua_panic_string(nelua_cstring2string(ma_result_description(result)));
          }
      };
      uint32_t flags = 16384U;
      {
          ma_result result = ma_sound_init_from_data_source((&fbdoom_machine_fbdoom_machine_audio_engine), (void*)(&audio_buffer->ref.ds), flags, ((ma_sound_ptr)NULL), sound);
          if((result != 0)) {
            nelua_panic_string(nelua_cstring2string(ma_result_description(result)));
          }
      };
      ma_sound_set_volume(sound, 0.2f);
      {
          ma_result result = ma_sound_start(sound);
          if((result != 0)) {
            nelua_panic_string(nelua_cstring2string(ma_result_description(result)));
          }
      };
      break;
    }
    case 2U: {
      break;
    }
    default: {
      nelua_panic_string(((nlstring){(uint8_t*)"unknown audio command", 21}));
      break;
    }
  }
}
void fbdoom_machine_fbdoom_machine_limit_fps(void) {
  if((fbdoom_machine_fbdoom_machine_desc.framebuffer.fps == 0)) {
    return;
  }
  double frame_delay = (1.0 / fbdoom_machine_fbdoom_machine_desc.framebuffer.fps);
  double now = nelua_os_now();
  if((fbdoom_machine_fbdoom_machine_next_frame_time > now)) {
    double delay = (fbdoom_machine_fbdoom_machine_next_frame_time - now);
    nelua_os_sleep(delay);
    fbdoom_machine_fbdoom_machine_next_frame_time = (fbdoom_machine_fbdoom_machine_next_frame_time + frame_delay);
  } else {
    fbdoom_machine_fbdoom_machine_next_frame_time = (now + frame_delay);
  }
}
void nelua_print_1(nlstring a1) {
  if(a1.size > 0) {
    fwrite(a1.data, 1, a1.size, stdout);
  }
  fputs("\n", stdout);
  fflush(stdout);
}
void fbdoom_machine_fbdoom_machine_machine_poll(void) {
  while(true) {
    CM_BREAK_REASON break_reason = cartesi_utils_CartesiMachine_run_1((&fbdoom_machine_fbdoom_machine_machine), NELUA_NIL);
    if((break_reason == 1)) {
      nelua_io_printf_1(((nlstring){(uint8_t*)"Machine HALTED\n", 15}));
      sapp_quit();
      return;
    } else if((break_reason != 3)) {
      nelua_print_1(((nlstring){(uint8_t*)"unexpected break reason", 23}));
      sapp_quit();
      return;
    }
    fbdoom_machine_fbdoom_machine_refresh_riv_desc();
    uint32_t yield_reason = cartesi_utils_CartesiMachine_read_yield_reason((&fbdoom_machine_fbdoom_machine_machine));
    switch(yield_reason) {
      case 1U: {
        fbdoom_machine_fbdoom_machine_present();
        return;
      }
      case 2U: {
        fbdoom_machine_fbdoom_machine_audio_ctl();
        break;
      }
      default: {
        nelua_panic_string(((nlstring){(uint8_t*)"unknown yield reason", 20}));
        break;
      }
    }
  }
}
void fbdoom_machine_fbdoom_machine_machine_frame_poll(void) {
  cartesi_utils_CartesiMachine_read_mcycle((&fbdoom_machine_fbdoom_machine_machine));
  nelua_os_now();
  fbdoom_machine_fbdoom_machine_machine_poll();
  cartesi_utils_CartesiMachine_read_mcycle((&fbdoom_machine_fbdoom_machine_machine));
  double time_end = nelua_os_now();
  fbdoom_machine_fbdoom_machine_frame_count = (fbdoom_machine_fbdoom_machine_frame_count + 1);
  fbdoom_machine_fbdoom_machine_last_frame_time = time_end;
}
void fbdoom_machine_fbdoom_machine_event(sapp_event_ptr event_1) {
  bool update = false;
  if((!event_1->key_repeat)) {
    if((event_1->type == 1)) {
      fbdoom_machine_fbdoom_machine_desc.keys[event_1->key_code].down_frame = (fbdoom_machine_fbdoom_machine_desc.frame + 1);
      update = true;
    } else if((event_1->type == 2)) {
      fbdoom_machine_fbdoom_machine_desc.keys[event_1->key_code].up_frame = (fbdoom_machine_fbdoom_machine_desc.frame + 1);
      update = true;
    }
  }
  if(update) {
    cartesi_utils_CartesiMachine_write_memory((&fbdoom_machine_fbdoom_machine_machine), 2170552320ULL, (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(nluint8_ptr)(&fbdoom_machine_fbdoom_machine_desc)), .size = 9296U});
  }
}
void nelua_panic_cstring(const char* s) {
  if(s) {
    nelua_write_stderr(s, strlen(s), true);
  }
  nelua_abort();
}
int64_t nelua_idiv_nlint64(int64_t a, int64_t b) {
  if(NELUA_UNLIKELY(b == -1)) return 0U - (uint64_t)a;
  if(NELUA_UNLIKELY(b == 0)) nelua_panic_cstring("division by zero");
  int64_t q = a / b;
  return q * b == a ? q : q - ((a < 0) ^ (b < 0));
}
void fbdoom_machine_fbdoom_machine_frame(void) {
  fbdoom_machine_fbdoom_machine_machine_frame_poll();
  int app_width = sapp_width();
  int app_height = sapp_height();
  sgp_begin(app_width, app_height);
  sgp_viewport(0, 0, app_width, app_height);
  sgp_project(0.0f, (float)app_width, 0.0f, (float)app_height);
  int64_t fb_height = (int64_t)fbdoom_machine_fbdoom_machine_desc.framebuffer.height;
  int64_t fb_width = (int64_t)fbdoom_machine_fbdoom_machine_desc.framebuffer.width;
  int64_t fb_pixel_count = (fb_height * fb_width);
  if((fb_pixel_count > 0)) {
    for(int64_t i = 0, _end = fb_pixel_count; i < _end; i += 1) {
      fbdoom_machine_fbdoom_machine_framebuffer_rgba.v[i] = fbdoom_machine_fbdoom_machine_desc.palette[fbdoom_machine_fbdoom_machine_framebuffer.v[i]];
    }
    sg_update_image(fbdoom_machine_fbdoom_machine_fb_image, NELUA_LITERAL_REF(sg_image_data, (({
      sg_image_data _tmp = {0};
      ((sg_range_arr16_arr6_cast*)&_tmp.subimage)->a = ({
        sg_range_arr16_arr6 _tmp = {0};
        ((sg_range_arr16_cast*)&_tmp.v[0])->a = (sg_range_arr16){{{.ptr = (void*)(&fbdoom_machine_fbdoom_machine_framebuffer_rgba.v[0]), .size = (size_t)(fb_pixel_count * 4)}}};
        _tmp;
      });
      _tmp;
    }))));
    double scale = 0.0;
    if(((fb_height * app_width) >= (fb_width * app_height))) {
      scale = ((app_height >= fb_height) ? (double)nelua_idiv_nlint64(app_height, fb_height) : (app_height / (double)fb_height));
    } else {
      scale = ((app_width >= fb_width) ? (double)nelua_idiv_nlint64(app_width, fb_width) : (app_width / (double)fb_width));
    }
    int64_t height = nelua_math_ifloor_1((fb_height * scale));
    int64_t width = nelua_math_ifloor_1((fb_width * scale));
    int64_t x = nelua_idiv_nlint64((app_width - width), 2);
    int64_t y = nelua_idiv_nlint64((app_height - height), 2);
    sgp_set_image(0, fbdoom_machine_fbdoom_machine_fb_image);
    sgp_draw_textured_rect((float)x, (float)y, (float)width, (float)height);
    sgp_reset_image(0);
  }
  sg_begin_default_pass(NELUA_LITERAL_REF(sg_pass_action, ((sg_pass_action){.colors = {{.action = 1, .value = {.r = 0.0f, .g = 0.0f, .b = 0.0f, .a = 1.0f}}}, .depth = {.action = 3}, .stencil = {.action = 3}})), app_width, app_height);
  sgp_flush();
  sgp_end();
  sg_end_pass();
  sg_commit();
  fbdoom_machine_fbdoom_machine_limit_fps();
}
void fbdoom_machine_fbdoom_machine_init(void) {
  {
      ma_result result = ma_engine_init(((ma_engine_config_ptr)NULL), (&fbdoom_machine_fbdoom_machine_audio_engine));
      if((result != 0)) {
        nelua_panic_string(nelua_cstring2string(ma_result_description(result)));
      }
  };
  sg_setup(NELUA_LITERAL_REF(sg_desc, ((sg_desc){.context = deps_sokol_glue_sapp_sgcontext()})));
  sgp_setup(NELUA_LITERAL_REF(sgp_desc, ((sgp_desc){0})));
}
void fbdoom_machine_fbdoom_machine_cleanup(void) {
  sg_destroy_image(fbdoom_machine_fbdoom_machine_fb_image);
  sgp_shutdown();
  sg_shutdown();
  ma_engine_uninit((&fbdoom_machine_fbdoom_machine_audio_engine));
}
int nelua_main(int argc, char** argv) {
  nelua_argc = argc;
  nelua_argv = argv;
  nelua_require_io(NELUA_NIL);
  nelua_require_arg(NELUA_NIL);
  fbdoom_machine_fbdoom_machine_machine = cartesi_utils_CartesiMachine_create((cm_machine_config){.ram = {.image_filename = (char*)"./images/linux-hugetlbfs-5.15.63-ctsi-1.bin", .length = 134217728U}, .rom = {.image_filename = (char*)"./images/rom-v0.15.0.bin", .bootargs = nelua_strlit_1}, .htif = {.yield_automatic = true}, .flash_drive = {.count = 1U, .entry = NELUA_LITERAL_REF(cm_memory_range_config_arr8, ((cm_memory_range_config_arr8){{{.start = 0x80000000000000ULL, .length = (uint64_t)fs_fs_stat_1(((nlstring){(uint8_t*)"./images/fbdoom_rootfs.ext2", 27}), NELUA_NIL).r1.size, .image_filename = (char*)"./images/fbdoom_rootfs.ext2"}}}))}});
  sapp_run((&fbdoom_machine_fbdoom_machine_app_desc));
  return 0;
}
int main(int argc, char** argv) {
  return nelua_main(argc, argv);
}
